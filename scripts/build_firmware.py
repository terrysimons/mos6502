#!/usr/bin/env python3
"""Build MicroPython firmware with frozen mos6502/c64 modules.

This builds custom MicroPython firmware (.uf2) with the emulator modules
frozen into flash. Frozen modules don't consume heap RAM, solving the
memory fragmentation issues on Pico.

Prerequisites:
    - Git (to clone MicroPython)
    - ARM toolchain: arm-none-eabi-gcc (for ARM builds)
    - RISC-V toolchain: riscv32-unknown-elf-gcc (for RISC-V builds)
    - CMake, Make

On macOS:
    brew install cmake arm-none-eabi-gcc
    # For RISC-V: brew tap riscv/riscv && brew install riscv-gnu-toolchain

On Ubuntu/Debian:
    sudo apt install cmake gcc-arm-none-eabi libnewlib-arm-none-eabi
    # For RISC-V: sudo apt install gcc-riscv64-unknown-elf

Usage:
    python scripts/build_firmware.py              # Build both ARM and RISC-V
    python scripts/build_firmware.py --arch arm   # Build ARM only
    python scripts/build_firmware.py --arch riscv # Build RISC-V only
    python scripts/build_firmware.py --clean      # Clean and rebuild
"""

import argparse
import os
import shutil
import subprocess
import sys
from pathlib import Path

from pico_config import (
    ROOT,
    MOS6502_SRC,
    C64_SRC,
    DIST_FIRMWARE,
    PICO2_BOARDS,
    PICO_EXCLUDE,
)

# MicroPython repository
MICROPYTHON_REPO = "https://github.com/micropython/micropython.git"
MICROPYTHON_DIR = ROOT / "micropython"

# Manifest template
# We freeze from a single parent directory to avoid C symbol conflicts
# (both mos6502/memory.py and c64/memory.py would conflict if frozen separately)
MANIFEST_TEMPLATE = '''# Frozen modules for C64 emulator
# Auto-generated by build_firmware.py

# Include default Pico modules
include("$(PORT_DIR)/boards/manifest.py")

# Freeze micropython-lib dependencies (single files)
freeze("{staging_path}", "ucontextlib.py", opt=0)

# Freeze mos6502 and c64 packages from the staging directory
# Using package() with base_path ensures correct module names (mos6502, c64, not frozen_modules/...)
package("{staging_path}/mos6502", base_path="{staging_path}", opt=0)
package("{staging_path}/c64", base_path="{staging_path}", opt=0)

# Freeze embedded ROMs if present
import os
if os.path.exists("{staging_path}/roms/__init__.py"):
    package("{staging_path}/roms", base_path="{staging_path}", opt=3)
'''


def run_command(cmd, cwd=None, check=True, env=None):
    """Run a command and print output."""
    print(f"  Running: {' '.join(cmd)}")
    result = subprocess.run(cmd, cwd=cwd, capture_output=True, text=True, env=env)
    if result.stdout:
        for line in result.stdout.strip().split('\n'):
            print(f"    {line}")
    if result.returncode != 0:
        print(f"  ERROR: Command failed with code {result.returncode}")
        if result.stderr:
            for line in result.stderr.strip().split('\n'):
                print(f"    {line}")
        if check:
            sys.exit(1)
    return result


def check_toolchain(arch):
    """Check if required toolchain is installed."""
    if arch == "arm":
        compiler = "arm-none-eabi-gcc"
    else:  # riscv
        # Try different RISC-V compiler names
        for name in ["riscv64-elf-gcc", "riscv32-unknown-elf-gcc", "riscv64-unknown-elf-gcc", "riscv-none-elf-gcc"]:
            if shutil.which(name):
                return True
        print(f"ERROR: RISC-V toolchain not found.")
        print("Install with:")
        print("  macOS: brew tap riscv-software-src/riscv && brew install riscv-tools")
        print("  Ubuntu: sudo apt install gcc-riscv64-unknown-elf")
        return False

    if not shutil.which(compiler):
        print(f"ERROR: {compiler} not found.")
        print("Install with:")
        print("  macOS: brew install arm-none-eabi-gcc")
        print("  Ubuntu: sudo apt install gcc-arm-none-eabi")
        return False
    return True


def clone_micropython():
    """Clone MicroPython repository if not present."""
    if MICROPYTHON_DIR.exists():
        print(f"MicroPython already cloned at {MICROPYTHON_DIR}")
        # Update to latest
        print("Updating MicroPython...")
        run_command(["git", "pull"], cwd=MICROPYTHON_DIR, check=False)
        return

    print(f"Cloning MicroPython to {MICROPYTHON_DIR}...")
    run_command(["git", "clone", "--depth", "1", MICROPYTHON_REPO, str(MICROPYTHON_DIR)])


def build_mpy_cross():
    """Build mpy-cross if not already built."""
    mpy_cross = MICROPYTHON_DIR / "mpy-cross" / "build" / "mpy-cross"
    if mpy_cross.exists():
        print("mpy-cross already built")
        return

    print("Building mpy-cross...")
    run_command(["make"], cwd=MICROPYTHON_DIR / "mpy-cross")


def prepare_frozen_modules():
    """Prepare modules directory for freezing.

    We copy modules to a staging directory, excluding files not needed on Pico.
    """
    staging_dir = DIST_FIRMWARE / "frozen_modules"

    # Clean staging directory
    if staging_dir.exists():
        shutil.rmtree(staging_dir)
    staging_dir.mkdir(parents=True)

    def should_exclude(rel_path):
        rel_str = str(rel_path)
        for pattern in PICO_EXCLUDE:
            if rel_str.endswith(pattern) or pattern in rel_str:
                return True
        return False

    # Copy mos6502
    print("Staging mos6502 modules...")
    mos6502_staging = staging_dir / "mos6502"
    count = 0
    for py_file in MOS6502_SRC.rglob("*.py"):
        if "__pycache__" in str(py_file) or "/tests/" in str(py_file):
            continue
        rel_path = py_file.relative_to(MOS6502_SRC)
        if should_exclude(rel_path):
            continue
        dest = mos6502_staging / rel_path
        dest.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(py_file, dest)
        count += 1
    print(f"  Staged {count} mos6502 files")

    # Copy c64
    print("Staging c64 modules...")
    c64_staging = staging_dir / "c64"
    count = 0
    for py_file in C64_SRC.rglob("*.py"):
        if "__pycache__" in str(py_file) or "/tests/" in str(py_file):
            continue
        rel_path = py_file.relative_to(C64_SRC)
        if should_exclude(rel_path):
            continue
        dest = c64_staging / rel_path
        dest.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(py_file, dest)
        count += 1
    print(f"  Staged {count} c64 files")

    # Download micropython-lib dependencies
    print("Downloading micropython-lib dependencies...")
    micropython_lib_modules = [
        # (module_name, url)
        ("ucontextlib", "https://raw.githubusercontent.com/micropython/micropython-lib/master/micropython/ucontextlib/ucontextlib.py"),
    ]
    for module_name, url in micropython_lib_modules:
        dest = staging_dir / f"{module_name}.py"
        try:
            import urllib.request
            print(f"  Downloading {module_name}...")
            urllib.request.urlretrieve(url, dest)
            print(f"  Downloaded {module_name}.py")
        except Exception as e:
            print(f"  WARNING: Failed to download {module_name}: {e}")

    # Copy ROM files if they exist (embed as Python module)
    # Search in multiple directories for ROMs
    rom_search_dirs = [
        ROOT / "tests" / "fixtures" / "c64" / "roms",
        ROOT / "roms",
        ROOT / "systems" / "c64" / "roms",
    ]

    # Map of ROM variable name to possible filenames (in priority order)
    rom_filenames = {
        "BASIC_ROM": ["basic.bin", "basic.rom", "basic", "basic.901226-01.bin"],
        "KERNAL_ROM": ["kernal.bin", "kernal.rom", "kernal", "kernal.901227-03.bin"],
        "CHAR_ROM": ["characters.bin", "characters.rom", "char.bin", "char.rom",
                     "char", "characters.901225-01.bin", "chargen"],
    }

    roms_found = {}
    for varname, filenames in rom_filenames.items():
        for search_dir in rom_search_dirs:
            if not search_dir.exists():
                continue
            for filename in filenames:
                rom_path = search_dir / filename
                if rom_path.exists():
                    roms_found[varname] = rom_path.read_bytes()
                    print(f"  Found {varname}: {rom_path}")
                    break
            if varname in roms_found:
                break

    if roms_found:
        print(f"Embedding ROMs: {', '.join(roms_found.keys())}")
        # Create a roms.py module with embedded ROM data
        roms_staging = staging_dir / "roms"
        roms_staging.mkdir(parents=True, exist_ok=True)

        # Create __init__.py with ROM data
        roms_py = roms_staging / "__init__.py"
        with open(roms_py, "w") as f:
            f.write('"""Embedded C64 ROM data for Pico firmware."""\n\n')
            for varname, data in roms_found.items():
                # Write as hex-escaped bytes literal
                hex_str = data.hex()
                f.write(f"{varname} = bytes.fromhex(\n")
                # Split into 64-char chunks for readability
                for i in range(0, len(hex_str), 64):
                    chunk = hex_str[i:i+64]
                    f.write(f'    "{chunk}"\n')
                f.write(")\n\n")
        print(f"  Created roms module ({sum(len(d) for d in roms_found.values())} bytes)")
    else:
        print("No ROM files found - ROMs not embedded")
        print("  Searched directories:")
        for search_dir in rom_search_dirs:
            exists = "exists" if search_dir.exists() else "not found"
            print(f"    {search_dir} ({exists})")

    return staging_dir


def create_manifest(staging_dir):
    """Create manifest.py for freezing modules."""
    manifest_content = MANIFEST_TEMPLATE.format(
        staging_path=str(staging_dir),
    )

    manifest_path = DIST_FIRMWARE / "manifest.py"
    manifest_path.write_text(manifest_content)
    print(f"Created manifest at {manifest_path}")
    return manifest_path


def build_firmware(arch, manifest_path, clean=False):
    """Build MicroPython firmware for specified architecture."""
    config = PICO2_BOARDS[arch]
    board = config["board"]
    platform = config["platform"]
    port_dir = MICROPYTHON_DIR / "ports" / "rp2"

    print(f"\nBuilding firmware for {board} ({arch})...")

    # Set up environment - use current Python (respects virtualenv/pyenv)
    env = os.environ.copy()
    env["PYTHON"] = sys.executable
    # Put current Python's directory first in PATH so CMake finds it
    python_dir = str(Path(sys.executable).parent)
    env["PATH"] = python_dir + os.pathsep + env.get("PATH", "")
    env["FROZEN_MANIFEST"] = str(manifest_path)
    print(f"  Using Python: {sys.executable}")

    # CMake arguments to force our Python
    cmake_args = f"-DPython3_EXECUTABLE={sys.executable}"

    # Build make arguments
    make_args = [f"BOARD={board}"]
    if platform:
        # For RISC-V, use MicroPython's BOARD_VARIANT mechanism
        # This loads mpconfigvariant_RISCV.cmake which sets PICO_PLATFORM correctly
        make_args.append("BOARD_VARIANT=RISCV")
        # Build dir is automatically set to build-RPI_PICO2-RISCV by Makefile
        build_dir_name = f"build-{board}-RISCV"

        # Find and set RISC-V toolchain path so cmake finds the right compiler
        riscv_compiler = None
        for name in ["riscv64-elf-gcc", "riscv32-unknown-elf-gcc", "riscv64-unknown-elf-gcc", "riscv-none-elf-gcc"]:
            path = shutil.which(name)
            if path:
                riscv_compiler = path
                break
        if riscv_compiler:
            toolchain_path = str(Path(riscv_compiler).parent.parent)
            env["PICO_TOOLCHAIN_PATH"] = toolchain_path
            # Also set the GCC triple for pico-sdk
            compiler_name = Path(riscv_compiler).name
            gcc_triple = compiler_name.replace("-gcc", "")
            env["PICO_GCC_TRIPLE"] = gcc_triple
            cmake_args += f" -DPICO_GCC_TRIPLE={gcc_triple}"
            print(f"  Using RISC-V toolchain: {toolchain_path} ({gcc_triple})")
    else:
        # ARM build directory (e.g., build-RPI_PICO2)
        build_dir_name = f"build-{board}"

    # Set CMAKE_ARGS in environment (not command line) so Makefile can append to it
    # If we pass it on command line, it overrides the Makefile's += assignments
    env["CMAKE_ARGS"] = cmake_args

    # Clean if requested - must delete build dir to clear CMake cache
    # Do this BEFORE submodules since submodules runs cmake
    if clean:
        print("Cleaning previous build...")
        build_dir_to_clean = port_dir / build_dir_name
        if build_dir_to_clean.exists():
            shutil.rmtree(build_dir_to_clean)
            print(f"  Removed {build_dir_to_clean}")

    # Initialize submodules if needed
    print("Initializing submodules...")
    run_command(["make"] + make_args + ["submodules"], cwd=port_dir, env=env)

    # Build with custom manifest
    num_cores = os.cpu_count() or 4
    build_cmd = ["make"] + make_args + [f"-j{num_cores}"]
    print(f"Building firmware: {' '.join(build_cmd)}")
    result = subprocess.run(
        build_cmd,
        cwd=port_dir,
        env=env,
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"ERROR: Build failed for {board} ({arch})")
        print("STDOUT:")
        print(result.stdout[-5000:] if len(result.stdout) > 5000 else result.stdout)
        print("STDERR:")
        print(result.stderr[-5000:] if len(result.stderr) > 5000 else result.stderr)
        return None

    # Print last part of build output for debugging
    if result.stdout:
        lines = result.stdout.strip().split('\n')
        print(f"  Build output ({len(lines)} lines, showing last 10):")
        for line in lines[-10:]:
            print(f"    {line}")

    # Find the output firmware (build dir is e.g., build-RPI_PICO2)
    build_dir = port_dir / build_dir_name
    firmware_uf2 = build_dir / "firmware.uf2"

    if not firmware_uf2.exists():
        # Try alternate build directory naming (without -RISCV suffix)
        alt_build_dir = port_dir / f"build-{board}"
        alt_firmware = alt_build_dir / "firmware.uf2"
        if alt_firmware.exists():
            firmware_uf2 = alt_firmware
        else:
            print(f"ERROR: Firmware not found at {firmware_uf2}")
            print(f"  Also checked: {alt_firmware}")
            # List available build directories
            print(f"  Available in {port_dir}:")
            for item in port_dir.iterdir():
                if item.is_dir() and item.name.startswith("build"):
                    print(f"    {item.name}/")
            return None

    # Copy to dist directory
    output_name = f"micropython-c64-pico2-{arch}.uf2"
    output_path = DIST_FIRMWARE / output_name
    shutil.copy2(firmware_uf2, output_path)

    # Get file size
    size_kb = output_path.stat().st_size / 1024
    print(f"  Built: {output_path} ({size_kb:.0f} KB)")

    return output_path


def clean_build_dirs(architectures, clean_all=False):
    """Clean build directories without building.

    Args:
        architectures: List of architectures to clean
        clean_all: If True, also clean mpy-cross and __pycache__ directories
    """
    port_dir = MICROPYTHON_DIR / "ports" / "rp2"

    # Clean MicroPython build directories
    print("MicroPython build directories:")
    for arch in architectures:
        board_info = PICO2_BOARDS.get(arch)
        if not board_info:
            continue
        board = board_info["board"]
        platform = board_info.get("platform")

        if platform:
            build_dir_name = f"build-{board}-RISCV"
        else:
            build_dir_name = f"build-{board}"

        build_dir = port_dir / build_dir_name
        if build_dir.exists():
            shutil.rmtree(build_dir)
            print(f"  Removed {build_dir}")
        else:
            print(f"  {build_dir} (not present)")

    # Clean entire dist/firmware directory (staging, .uf2, .mpy files)
    print("\nDist directory:")
    if DIST_FIRMWARE.exists():
        shutil.rmtree(DIST_FIRMWARE)
        print(f"  Removed {DIST_FIRMWARE}")
    else:
        print(f"  {DIST_FIRMWARE} (not present)")

    # Also clean dist/pico if it exists (.mpy deployment files)
    from pico_config import DIST_PICO
    print("\nPico deployment directory:")
    if DIST_PICO.exists():
        shutil.rmtree(DIST_PICO)
        print(f"  Removed {DIST_PICO}")
    else:
        print(f"  {DIST_PICO} (not present)")

    if clean_all:
        # Clean mpy-cross build
        mpy_cross_build = MICROPYTHON_DIR / "mpy-cross" / "build"
        print("\nmpy-cross build directory:")
        if mpy_cross_build.exists():
            shutil.rmtree(mpy_cross_build)
            print(f"  Removed {mpy_cross_build}")
        else:
            print(f"  {mpy_cross_build} (not present)")

        # Clean __pycache__ directories in mos6502 and systems/c64
        print("\n__pycache__ directories:")
        for search_dir in [ROOT / "mos6502", ROOT / "systems" / "c64"]:
            if search_dir.exists():
                for pycache in search_dir.rglob("__pycache__"):
                    shutil.rmtree(pycache)
                    print(f"  Removed {pycache}")

        # Clean /lib on connected Pico device (removes filesystem overrides)
        print("\nPico device /lib directory:")
        mpremote = shutil.which("mpremote")
        if mpremote:
            try:
                # Check if device is connected and /lib exists
                result = subprocess.run(
                    [mpremote, "fs", "ls", "/lib/"],
                    capture_output=True,
                    text=True,
                    timeout=5,
                )
                if result.returncode == 0 and result.stdout.strip():
                    # Remove /lib directory recursively
                    subprocess.run(
                        [mpremote, "exec", "import os; [os.remove('/lib/' + f) if not os.stat('/lib/' + f)[0] & 0x4000 else None for f in os.listdir('/lib/')]"],
                        capture_output=True,
                        timeout=10,
                    )
                    # Try to remove subdirectories (c64, mos6502, etc.)
                    for subdir in ["c64", "mos6502", "roms"]:
                        subprocess.run(
                            [mpremote, "exec", f"import os\ntry:\n    for f in os.listdir('/lib/{subdir}'):\n        try: os.remove('/lib/{subdir}/' + f)\n        except: pass\n    os.rmdir('/lib/{subdir}')\nexcept: pass"],
                            capture_output=True,
                            timeout=10,
                        )
                    print("  Cleaned /lib on device")
                else:
                    print("  /lib not present or empty on device")
            except subprocess.TimeoutExpired:
                print("  No device connected (timeout)")
            except Exception as e:
                print(f"  Could not clean device: {e}")
        else:
            print("  mpremote not found, skipping device clean")


def main():
    parser = argparse.ArgumentParser(
        description="Build MicroPython firmware with frozen C64 emulator modules"
    )
    parser.add_argument(
        "--arch",
        choices=["arm", "riscv", "both"],
        default="both",
        help="Target architecture (default: both)"
    )
    parser.add_argument(
        "--build",
        action="store_true",
        help="Build firmware (required unless --clean-only)"
    )
    parser.add_argument(
        "--clean",
        action="store_true",
        help="Clean build directories before building (use with --build)"
    )
    parser.add_argument(
        "--clean-only",
        action="store_true",
        help="Only clean build directories, don't build"
    )
    parser.add_argument(
        "--clean-all",
        action="store_true",
        help="Deep clean: also remove mpy-cross build and __pycache__ dirs"
    )
    parser.add_argument(
        "--skip-clone",
        action="store_true",
        help="Skip cloning/updating MicroPython (use existing)"
    )
    args = parser.parse_args()

    # Determine architectures
    if args.arch == "both":
        architectures = ["arm", "riscv"]
    else:
        architectures = [args.arch]

    # Handle clean-only mode
    if args.clean_only:
        print("=" * 60)
        print("Cleaning Build Directories" + (" (deep clean)" if args.clean_all else ""))
        print("=" * 60)
        print("\nCleaning...")
        clean_build_dirs(architectures, args.clean_all)
        print("\nClean complete.")
        return

    # Require --build flag to actually build
    if not args.build:
        print("Usage: build_firmware.py --build [--arch arm|riscv|both] [--clean] [--clean-all]")
        print("       build_firmware.py --clean-only [--clean-all] [--arch arm|riscv|both]")
        print("\nOptions:")
        print("  --build       Build firmware")
        print("  --clean       Clean before building (use with --build)")
        print("  --clean-only  Only clean, don't build")
        print("  --clean-all   Deep clean: mpy-cross, __pycache__ (use with --clean or --clean-only)")
        print("  --arch        Target architecture (default: both)")
        print("  --skip-clone  Skip MicroPython clone/update")
        sys.exit(0)

    print("=" * 60)
    print("Building MicroPython Firmware with Frozen Modules")
    print("=" * 60)

    # If --clean flag, clean everything first
    if args.clean:
        print("\nCleaning all build directories first" + (" (deep clean)" if args.clean_all else "") + "...")
        clean_build_dirs(architectures, args.clean_all)

    # Check toolchains
    print("\nChecking toolchains...")
    for arch in architectures:
        if not check_toolchain(arch):
            sys.exit(1)
        print(f"  {arch}: OK")

    # Clone/update MicroPython
    if not args.skip_clone:
        print("\nPreparing MicroPython...")
        clone_micropython()
        build_mpy_cross()

    # Create output directory
    DIST_FIRMWARE.mkdir(parents=True, exist_ok=True)

    # Prepare frozen modules
    print("\nPreparing frozen modules...")
    staging_dir = prepare_frozen_modules()

    # Create manifest
    manifest_path = create_manifest(staging_dir)

    # Build firmware for each architecture
    results = {}
    for arch in architectures:
        result = build_firmware(arch, manifest_path, clean=args.clean)
        results[arch] = result

    # Summary
    print("\n" + "=" * 60)
    print("Build Summary")
    print("=" * 60)

    success = True
    for arch, path in results.items():
        if path:
            print(f"  {arch}: {path}")
        else:
            print(f"  {arch}: FAILED")
            success = False

    if success:
        print("\nTo flash firmware:")
        print("  1. Hold BOOTSEL button on Pico 2")
        print("  2. Connect USB while holding BOOTSEL")
        print("  3. Copy .uf2 file to the RPI-RP2 drive")
        print(f"\nFirmware files are in: {DIST_FIRMWARE}")

    print("=" * 60)

    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
